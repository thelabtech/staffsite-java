/* Generated by Together */

package org.alt60m.ministry.statistics;
import java.util.*;
//import org.alt60m.util.TextUtils;
import org.alt60m.ministry.Strategies;
public class StatsUtils {

	// Takes a bunch of stats for a campus, and separates them into individual strategies collecions
	// THE INPUT LIST MUST BE SORTED BY DATE
	public static Map separateStatsByStrategy(List statistics) {
		Map strategiesStats = new Hashtable();
	
		Iterator iStats = statistics.iterator();
		while(iStats.hasNext()) {
			Hashtable stat = (Hashtable) iStats.next();
			String strategy = Strategies.expandStrategy((String) stat.get("Strategy"));
			Collection stats = (Collection) strategiesStats.get(strategy);
			if (stats == null) {
				stats = new Vector();
				strategiesStats.put(strategy, stats);
			}
			
			stats.add(stat);
		}

		return strategiesStats;
	}

	// Takes a bunch of stats for a campus, and separates them into individual strategies collecions
	// THE INPUT LIST MUST BE SORTED BY DATE
	public static Map separateStatsByCampus(List statistics) {
		Map campusStats = new TreeMap();
	
		Iterator iStats = statistics.iterator();
		while(iStats.hasNext()) {
			Hashtable stat = (Hashtable) iStats.next();
			String campusName = (String) stat.get("Name");
			Collection stats = (Collection) campusStats.get(campusName);
			if (stats == null) {
				stats = new Vector();
				campusStats.put(campusName, stats);
			}
			
			stats.add(stat);
		}

		return campusStats;
	}

	// Takes a list of statistics
	// Returns a list of summaries grouped by campus
	static public Collection groupStatisticsListByCampus(List statisticsList) {
		Collection campusSummaries = new Vector(); 

		// Separate by campus
		Map campusStats = separateStatsByCampus(statisticsList);
		
		// For each campus
		for(Iterator iCampuses = campusStats.values().iterator(); iCampuses.hasNext();) {	
			
			// Overall summary for a particular campus
			Hashtable summaryForCampus = new Hashtable();
			
			List theCampusStats = (List)iCampuses.next();
			
			// Make sure that campus information is maintained
			summaryForCampus.put("Name", ((Hashtable) theCampusStats.get(0)).get("Name"));
			summaryForCampus.put("TargetAreaID", ((Hashtable) theCampusStats.get(0)).get("TargetAreaID"));

			// Separate stats by strategy
			Map strategyStats = separateStatsByStrategy(theCampusStats);
			
			// For each strategy, build the summary
			Map summariesForStrategies = buildReportSummaries(strategyStats);
			

			
			// Go thru the strategies and generate a campus summary
			// Notice the 'true' in updateSummary.  We want to cumulate the demographics, in this case
			for (Iterator iSummaries = summariesForStrategies.values().iterator();iSummaries.hasNext();) {
				updateSummary(summaryForCampus, (Hashtable) iSummaries.next(), true);
			}
		
			campusSummaries.add(summaryForCampus);
		}	

		return campusSummaries;

	}
	public static Map buildReportSummaries(Map dataForStrategies) {
			
		Map results = new Hashtable();

		Iterator i = dataForStrategies.keySet().iterator();
		while(i.hasNext()) {
			String strategy = (String) i.next();	
			results.put( 
				strategy, 
				buildReportSummary((Collection) dataForStrategies.get(strategy), false)
			);
		}
		return results;

	}


	public static Hashtable buildReportSummary(Collection statistics, boolean cumulateAllFields) {
			
		Iterator i = statistics.iterator();
		Hashtable summary = new Hashtable();

		while(i.hasNext()) {
			Hashtable row = (Hashtable) i.next();
			updateSummary(summary, row, cumulateAllFields);
		}

		return summary;
	}
	
	public static void updateSummary(Hashtable summary, Hashtable row, boolean cumulateAllFields) {
		final String[] currentStatusFields = new String[] {"Exposures", "Decisions", "AttendedLastConf"};
		final String[] demographicFields = new String[]{"InvldNewBlvrs", "InvldStudents", "InvldFreshmen", "InvldSophomores", "InvldJuniors", "InvldSeniors", "InvldGrads", "Volunteers", "Staff", "NonStaffStint", "StaffStint"};
		
		if (cumulateAllFields) {
			updateSummaryWithRowCumulate(summary, row, currentStatusFields);
			updateSummaryWithRowCumulate(summary, row, demographicFields);
		} else {
			updateSummaryWithRowCumulate(summary, row, currentStatusFields);
			updateSummaryWithRowByLastDate(summary, row, demographicFields);
		}

	}

	public static void updateSummaryWithRowCumulate(Hashtable summary, Hashtable row, String[] cumulateFields) {

		// Summate fields ***************************************************************************
		for (int field = 0; field < cumulateFields.length;field++ ) {
			String fieldName = cumulateFields[field];
			if(!summary.containsKey(fieldName)) 
				summary.put(fieldName, row.get(fieldName));
			else
				summary.put(fieldName,
					new Integer(((Integer) summary.get(fieldName)).intValue() + ((Integer) row.get(fieldName)).intValue())
			);
		}
	}

	public static void updateSummaryWithRowByLastDate(Hashtable summary, Hashtable row, String[] lastDateFields) {
		// Get last value fields ********************************************************************
		Date lastSummaryDate = (Date) summary.get("PeriodEnd");
		Date thisRowDate = (Date) row.get("PeriodEnd");

		for (int field = 0; field < lastDateFields.length;field++ ) {
			// If the summary doesn't contain periodEnd yet or if this row is newer, put it in the summary			
			if ((lastSummaryDate == null) || (lastSummaryDate.compareTo(thisRowDate) <= 0) ) {
				summary.put("PeriodEnd", thisRowDate); // get the last date
				summary.put(lastDateFields[field], row.get(lastDateFields[field]));				
			}
		}
	}
}
