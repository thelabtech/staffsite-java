/* Generated by Together */


package org.alt60m.ministry.model;
import java.util.*;
import org.alt60m.util.LogHelper;
import org.apache.log4j.Priority;

/**
 * @persistent 
 * @table ministry_ChangeRequest
 * @key-generator UUID
 * @cache-type none
 * @access shared
 */
public class ChangeRequest {
	/**
	 * @primary-key
	 */
    private String changeRequestID = new String();
    private Date requestDate;
    private Date effectiveDate;
    private Date appliedDate;
    private String type = new String();
    
	//Log Helper Code//
	private static LogHelper logHelper = new LogHelper();
	private void log(Priority p, String msg) { logHelper.log(this.getClass().toString(),p,msg); }
//	private void log(Priority p, String msg, java.lang.Throwable t) { logHelper.log(this.getClass().toString(),p,msg,t); }
	//End of Log Helper Code//
    
	public Date getRequestDate() {
		return requestDate; 
	}
	public void setRequestDate(Date requestDate) {
	    if (requestDate != null) {
		Calendar cin = Calendar.getInstance();
		Calendar cout = Calendar.getInstance();
		cin.setTime(requestDate);
		cout.clear();
		cout.set(cin.get(Calendar.YEAR), cin.get(Calendar.MONTH), cin.get(Calendar.DATE));
		this.requestDate = cout.getTime();
	    } else {
		this.requestDate = requestDate;
	    }	    
	}
	public Date getEffectiveDate() {
		return effectiveDate; 
	}
	public void setEffectiveDate(Date effectiveDate) {
	    if (effectiveDate != null) {
		Calendar cin = Calendar.getInstance();
		Calendar cout = Calendar.getInstance();
		cin.setTime(effectiveDate);
		cout.clear();
		cout.set(cin.get(Calendar.YEAR), cin.get(Calendar.MONTH), cin.get(Calendar.DATE));
		this.effectiveDate = cout.getTime();
	    } else {
		this.effectiveDate = effectiveDate; 
	    }	    
	}
	public Date getAppliedDate() {
		return appliedDate; 
	}
	public void setAppliedDate(Date appliedDate) {
	    if (appliedDate != null) {
		Calendar cin = Calendar.getInstance();
		Calendar cout = Calendar.getInstance();
		cin.setTime(appliedDate);
		cout.clear();
		cout.set(cin.get(Calendar.YEAR), cin.get(Calendar.MONTH), cin.get(Calendar.DATE));
		this.appliedDate = cout.getTime();
	    } else {
		this.appliedDate = appliedDate;
	    }	    
	}
	public String getType() {
		return type; 
	}
	public void setType(String type) {
		this.type = type; 
	}

    public String getChangeRequestID(){
            return changeRequestID;
        }

    public void setChangeRequestID(String changeRequestID){
            this.changeRequestID = changeRequestID;
        }

    public Staff getRequestedBy(){
            return requestedBy;
        }

    public void setRequestedBy(Staff requestedBy){
            this.requestedBy = requestedBy;
        }

    public void assocRequestedBy(Staff requestedBy){
            this.requestedBy = requestedBy;
        }

    public Collection getAuthorizations(){
            return authorizations;
        }

    public void setAuthorizations(Collection authorizations){
            this.authorizations = authorizations;
        }

    public void assocAuthorization(Authorization auth) {
		this.authorizations.add(auth);
        auth.setChangeRequest(this);
    }

    public Collection getFieldChanges(){
            return fieldChanges;
        }

    public void setFieldChanges(Collection fieldChanges){
            this.fieldChanges = fieldChanges;
        }

    public void assocFieldChange(FieldChange newFieldChange) {
		this.fieldChanges.add(newFieldChange);
        newFieldChange.setChangeRequest(this);
    }

    /**
     * @field-type org.alt60m.ministry.model.FieldChange
     * @many-key fk_changeRequestID
     */
    private Collection fieldChanges = new Vector();

    /**
     * @field-type org.alt60m.ministry.model.Authorization
     * @many-key fk_changeRequestID
     */
    private Collection authorizations = new Vector();

	private Staff requestedBy;

    public int getNumRemainingAuths() {
	Collection authorizations = this.getAuthorizations();
	Iterator it = authorizations.iterator();
	int remainingAuths = 0;
	while (it.hasNext()) {
	    Authorization nextAuth = (Authorization) it.next();
	    if (nextAuth.getAuthorized() == null || nextAuth.getAuthorized().equals("") || nextAuth.getAuthorized().equals("N")) {
		remainingAuths++;
	    }
	}
	return remainingAuths;
    }

    //is anyone waiting on a non-campus approval?  has everyone before non-campus said yes?  well, then non-campus says yes also
	public void applyHrncApprovals() {
		Collection authorizations = this.getAuthorizationsBySequence();
		Iterator it = authorizations.iterator();
		while (it.hasNext()) {
			Authorization nextAuth = (Authorization) it.next();
			if (nextAuth.getRole().equals("HRRD") || nextAuth.getRole().equals("HRND")) {
				if (!nextAuth.getAuthorized().equals("Y")) {
					break;
				}
			} else if (nextAuth.getRole().equals("HRNC") && (nextAuth.getAuthorized() == null || nextAuth.getAuthorized().equals(""))){
				log(Priority.INFO,"making non-campus approval***********" + nextAuth.getAuthorizationID());
				nextAuth.setAuthorized("Y");
				nextAuth.setAuthDate(new java.sql.Date(System.currentTimeMillis()));
			}
		}
	}

    public List getAuthorizationsBySequence() {
	List orderedAuths = new ArrayList();
	for (int i=1;i<=authorizations.size();i++) {
	    Iterator it = authorizations.iterator();
	    while (it.hasNext()) {
		try {
		    Authorization authObj = (Authorization) it.next();
		    if (authObj.getSequence() == i) {
			orderedAuths.add(authObj);
		    }		     
		} catch (NullPointerException e) {
			log(Priority.ERROR,"ChangeRequest " + changeRequestID + " has a null authorization");
		}
	    }
	}
	return orderedAuths;
    }
}
